// Based on Jeff Wilcox' Syntax highlighter: http://www.jeff.wilcox.name/2010/03/syntax-highlighting-text-block/
// He really deservces most of the credits...

// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.
// <auto-generated />
// No style analysis for imported project.

using System.Collections.Generic;
using System.IO;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Documents;

namespace SharpGIS.SyntaxHighlighting
{
    // CONSIDER: background worker to improve performance, with all UI
    // generation at the end.

    internal class XamlInlineFormatter : IFormatter
    {
        private TextBlock _text;

        public XamlInlineFormatter(Panel panel) : this()
        {
            _text = new TextBlock { TextWrapping = System.Windows.TextWrapping.Wrap };
            panel.Children.Add(_text);
        }

        /// <summary>
        /// Initializes a new instance of the XAML inline formatter which will
        /// store the contents of the syntax highlighting results into the
        /// text block instance.
        /// </summary>
        /// <param name="textBlock">The text block.</param>
        public XamlInlineFormatter(TextBlock textBlock)
            : this()
        {
            _text = textBlock;
        }

        protected XamlInlineFormatter()
        {
        }

        public void Write(string parsedSourceCode,
                          IList<Scope> scopes,
                          IStyleSheet styleSheet)
        {
            var styleInsertions = new List<TextInsertion>();

            int offset = 0;
            bool lastScopeWasComment = false;
			int lastoffset = 0;
            foreach (Scope scope in scopes)
            {
				if (lastoffset < scope.Index)
				{
					string space = parsedSourceCode.Substring(lastoffset, scope.Index - lastoffset);
					Inline run = new Run { Text = space.Replace("\r", string.Empty) };
					_text.Inlines.Add(run);
				}
                string t = parsedSourceCode.Substring(scope.Index, scope.Length);
				lastoffset = scope.Index + scope.Length;
//                    .Replace("\r\n", "\n")
//                    .Replace("\r", "\n");
                offset = scope.Index + scope.Length;
                if (!string.IsNullOrEmpty(t))
                {
                    Inline run = new Run { Text = t.Replace("\r",string.Empty) };
                    if (scope != null && styleSheet.Styles.Contains(scope.Name))
                    {
                        Style style = styleSheet.Styles[scope.Name];
                        run.Foreground = new SolidColorBrush(style.Foreground);
                    }
                    lastScopeWasComment = (scope != null && scope.Name == "Comment");
                    _text.Inlines.Add(run);
                }
            }
            string left = parsedSourceCode
                .Substring(offset)
                .Replace("\r\n", "\n")
                .Replace("\r", "\n");
            if (!string.IsNullOrEmpty(left))
            {
                for (int i = left.IndexOf("\n"); i >= 0; i = left.IndexOf("\n"))
                {
                    if (i > 0)
                    {
                        Inline tby = new Run { Text = left.Substring(0, i) };
                        _text.Inlines.Add(tby);
                    }

                    left = left.Substring(i + 1);
                    if (lastScopeWasComment)
                    {
                        lastScopeWasComment = false;
                    }
                    else
                    {
                        _text.Inlines.Add(new LineBreak());
                    }
                }

                if (!string.IsNullOrEmpty(left))
                {
                    Inline nrun = new Run { Text = left };
                    _text.Inlines.Add(nrun);
                }
            }
        }

        private static void GetStyleInsertionsForCapturedStyle(Scope scope, ICollection<TextInsertion> styleInsertions)
        {
            styleInsertions.Add(new TextInsertion
            {
                Index = scope.Index,
                Scope = scope
            });

            foreach (Scope childScope in scope.Children)
                GetStyleInsertionsForCapturedStyle(childScope, styleInsertions);

            styleInsertions.Add(new TextInsertion
            {
                Index = scope.Index + scope.Length,
                //                Text = ""
            });
        }

        private static void BuildSpanForCapturedStyle(Scope scope,
                                                        IStyleSheet styleSheet)
        {
            Color foreground = Colors.Black;
            Color background = Colors.Transparent;

            if (styleSheet.Styles.Contains(scope.Name))
            {
                Style style = styleSheet.Styles[scope.Name];

                foreground = style.Foreground;
                background = style.Background;
            }

            WriteElementStart("span", foreground, background);
        }

        private static void WriteHeaderDivEnd()
        {
            WriteElementEnd("div");
        }

        private static void WriteElementEnd(string elementName)
        {
        }

        private static void WriteHeaderPreEnd()
        {
            WriteElementEnd("pre");
        }

        private static void WriteHeaderPreStart()
        {
            WriteElementStart("pre");
        }

        private static void WriteHeaderDivStart(IStyleSheet styleSheet)
        {
            Color foreground = Colors.Transparent;
            Color background = Colors.Transparent;

            if (styleSheet.Styles.Contains(ScopeName.PlainText))
            {
                Style plainTextStyle = styleSheet.Styles[ScopeName.PlainText];

                foreground = plainTextStyle.Foreground;
                background = plainTextStyle.Background;
            }

            WriteElementStart("div", foreground, background);
        }

        private static void WriteElementStart(string elementName)
        {
            WriteElementStart(elementName, Colors.Transparent, Colors.Transparent);
        }

        private static void WriteElementStart(string elementName,
                                              Color foreground,
                                              Color background)
        {
            if (foreground != Colors.Transparent || background != Colors.Transparent)
            {
            }
        }
    }
}